{"version":3,"sources":["components/ToDoList.js","components/ToDoItems.js","App.js","serviceWorker.js","index.js"],"names":["ToDoList","state","inputText","handleSubmit","e","preventDefault","props","addItem","setState","handleChange","target","name","value","this","className","onSubmit","placeholder","onChange","autocomplete","type","Component","ToDoItems","items","deleteItem","map","item","index","key","charAt","toUpperCase","slice","onClick","App","task","newArr","id","console","log","filter","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","ReactDOM","render","StrictMode","document","getElementById","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.b9bfa88e.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nclass ToDoList extends Component {\r\n  state = {\r\n    inputText: \"\",\r\n  };\r\n  //I don't need to define items in the state here because we don't use it in this component.\r\n\r\n  handleSubmit = (e) => {\r\n    e.preventDefault();\r\n    this.props.addItem(this.state.inputText);\r\n    this.setState({inputText: \"\"})\r\n    //here we are defining (with this.props.) and calling the addItem function which I created in the App.js parent component.\r\n  };\r\n\r\n  handleChange = (e) => {\r\n    this.setState({ [e.target.name]: e.target.value });\r\n  };\r\n\r\n  render() {\r\n    const { inputText } = this.state;\r\n\r\n    return (\r\n      <div className=\"formWrapper\">\r\n          <form onSubmit={this.handleSubmit}>\r\n            <input\r\n              name=\"inputText\"\r\n              value={inputText}\r\n              placeholder=\"Next task\"\r\n              onChange={this.handleChange}\r\n              autocomplete=\"off\"\r\n            />\r\n            <button className=\"addButton\" type=\"submit\"> Add </button>\r\n          </form>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ToDoList;\r\n","import React from \"react\";\r\n\r\nconst ToDoItems = (props) => {\r\n  const { items, deleteItem } = props;\r\n\r\n  return (\r\n      <ul>\r\n        {items.map((item, index) => {\r\n        // for(i=0;i<items.length;i++) {}\r\n          return (\r\n            <div className=\"liButtonWrapper\" key={index}>\r\n              <li>{item.charAt(0).toUpperCase() + item.slice(1)}</li>\r\n              <button className=\"doneButton\" type=\"button\" onClick={() => deleteItem(index)}>\r\n                Done\r\n              </button>\r\n            </div>\r\n          );\r\n        })}\r\n      </ul>\r\n  );\r\n};\r\n//items are the props that I am referring to here.\r\n//singular item is what the map method is using as a parameter to refer to a single item in an array. We always need to use the singular version of whatever our array contains here.\r\n\r\nexport default ToDoItems;\r\n","import React, { Component } from \"react\";\r\nimport \"./App.css\";\r\nimport ToDoList from \"./components/ToDoList\";\r\nimport ToDoItems from \"./components/ToDoItems\";\r\n\r\n//Read up more on arrays, objects (and how to manipulate them). Also learn how to write functions and add items into an object and add items into an array. For the task list, I need an array of objects. Learn how to put them in and out of arrays.\r\n\r\n//Recreate this app.\r\n\r\nclass App extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      items: [],\r\n    };\r\n  }\r\n\r\n  //we don't need to define inputText in the constructor here because we aren't using it in the app component.\r\n\r\n  addItem = (task) => {\r\n    //using object destructuring here to avoid writing this.state.items various times below.\r\n    const { items } = this.state;\r\n    const newArr = [...items, task];\r\n\r\n    //this has to be the same as the parameter passed through.\r\n    this.setState({ items: newArr });\r\n  };\r\n\r\n  deleteItem = (id) => {\r\n    console.log(id);\r\n    let items = this.state.items.filter((item, index) => {\r\n      return index !== id;\r\n    });\r\n    this.setState({ items });\r\n  };\r\n\r\n  render() {\r\n    const { items } = this.state;\r\n    //this is so that I don't need to write this.state.items below (object destructuring)\r\n\r\n    return (\r\n      <div className=\"App\">\r\n        <h1>To Do List</h1>\r\n        <div className=\"todoListWrapper\">\r\n          <ToDoList addItem={this.addItem} />\r\n        </div>\r\n        <div className=\"itemsWrapper\">\r\n          <ToDoItems items={items} deleteItem={this.deleteItem} />\r\n        </div>\r\n      </div>\r\n    );\r\n    //in the tags I am passing the props down to the child components (ToDoItems)\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport \"./index.css\";\r\nimport App from \"./App\"\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}